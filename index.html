<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Urban Velocity - Street Racing Game</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/6.5.8/pixi.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/echarts/5.4.0/echarts.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Inter:wght@300;400;500;600&family=JetBrains+Mono:wght@400;500&family=Audiowide&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Inter', sans-serif;
            background: radial-gradient(circle at top, #15181f 0%, #050607 55%, #000000 100%);
            color: #ffffff;
            overflow: hidden;
            height: 100vh;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            background: #000;
        }

        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #uiOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
        }

        .ui-panel {
            pointer-events: auto;
            background: rgba(10, 12, 18, 0.9);
            border: 1px solid rgba(0, 212, 255, 0.3);
            border-radius: 12px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 212, 255, 0.1);
        }

        #speedometer {
            position: absolute;
            bottom: 40px;
            right: 40px;
            width: 200px;
            height: 200px;
            background: radial-gradient(circle, rgba(0, 212, 255, 0.15) 0%, rgba(8, 12, 20, 0.98) 65%);
            border: 2px solid #00d4ff;
            border-radius: 50%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-family: 'JetBrains Mono', monospace;
            position: relative;
            overflow: hidden;
        }

        #speedometer::before {
            content: '';
            position: absolute;
            inset: -2px;
            border-radius: 50%;
            background: conic-gradient(from 0deg, #00d4ff, #ff6b35, #ff00ff, #00d4ff);
            z-index: -1;
            animation: rotate 3s linear infinite;
            opacity: 0.5;
        }

        #speedometer::after {
            content: '';
            position: absolute;
            inset: 6px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(9, 12, 20, 0.98) 0%, rgba(0, 0, 0, 0.98) 80%);
            z-index: 0;
        }

        .speed-value {
            position: relative;
            font-size: 2.6rem;
            font-weight: 700;
            color: #00d4ff;
            text-shadow: 0 0 30px rgba(0, 212, 255, 0.8);
            z-index: 1;
        }

        .speed-unit {
            position: relative;
            font-size: 0.9rem;
            color: #9ca3af;
            margin-top: -5px;
            letter-spacing: 0.15em;
            z-index: 1;
        }

        #minimap {
            position: absolute;
            top: 40px;
            right: 40px;
            width: 220px;
            height: 220px;
            background: radial-gradient(circle at center, #070b11 0%, #020308 100%);
            border: 1px solid #00d4ff;
            border-radius: 16px;
            overflow: hidden;
        }

        #scoreDisplay {
            position: absolute;
            top: 40px;
            left: 40px;
            padding: 20px 22px;
            font-family: 'Orbitron', monospace;
        }

        .score-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            font-size: 1rem;
        }

        .score-label {
            color: #6b7280;
            margin-right: 10px;
            min-width: 80px;
            letter-spacing: 0.08em;
            font-size: 0.8rem;
        }

        .score-value {
            color: #00d4ff;
            font-weight: 600;
            text-shadow: 0 0 10px rgba(0, 212, 255, 0.4);
        }

        #controlPanel {
            position: absolute;
            bottom: 40px;
            left: 40px;
            padding: 16px 18px;
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .control-btn {
            padding: 10px 20px;
            background: linear-gradient(135deg, #00d4ff, #0099cc);
            border: none;
            border-radius: 999px;
            color: white;
            font-family: 'Inter', sans-serif;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.12em;
            font-size: 0.75rem;
        }

        .control-btn:hover {
            transform: translateY(-1px) scale(1.02);
            box-shadow: 0 8px 25px rgba(0, 212, 255, 0.4);
        }

        .control-btn:active {
            transform: translateY(0) scale(0.99);
        }

        #gameMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 40px 48px;
            text-align: center;
            z-index: 20;
            background: radial-gradient(circle at top, rgba(17, 24, 39, 0.96), rgba(3, 7, 18, 0.98));
            border: 1px solid rgba(0, 212, 255, 0.5);
            border-radius: 24px;
            backdrop-filter: blur(16px);
            box-shadow: 0 30px 80px rgba(0, 0, 0, 0.9);
        }

        #gameMenu::before {
            content: '';
            position: absolute;
            inset: -2px;
            border-radius: 24px;
            padding: 1px;
            background: linear-gradient(135deg, rgba(0, 212, 255, 0.7), rgba(255, 107, 53, 0.7));
            -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            -webkit-mask-composite: xor;
                    mask-composite: exclude;
            opacity: 0.7;
        }

        #gameMenu h1 {
            font-family: 'Audiowide', cursive;
            font-size: 3rem;
            color: #00f2ff;
            margin-bottom: 4px;
            text-shadow: 0 0 30px rgba(0, 242, 255, 0.7);
            letter-spacing: 0.18em;
        }

        .menu-subtitle {
            font-size: 1.05rem;
            color: #9ca3af;
            margin-bottom: 26px;
            font-weight: 300;
            letter-spacing: 0.12em;
            text-transform: uppercase;
        }

        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-bottom: 26px;
        }

        .menu-btn {
            padding: 13px 40px;
            background: linear-gradient(135deg, #ff6b35, #ff1f71);
            border: none;
            border-radius: 999px;
            color: white;
            font-family: 'Orbitron', monospace;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.25s ease;
            text-transform: uppercase;
            letter-spacing: 0.18em;
            position: relative;
            overflow: hidden;
        }

        .menu-btn::after {
            content: '';
            position: absolute;
            inset: 0;
            background: radial-gradient(circle at 0 0, rgba(255,255,255,0.3), transparent 55%);
            opacity: 0;
            transition: opacity 0.25s ease;
        }

        .menu-btn:hover::after {
            opacity: 1;
        }

        .menu-btn:hover {
            transform: translateY(-2px) scale(1.02);
            box-shadow: 0 15px 40px rgba(255, 107, 53, 0.4);
        }

        #loadingScreen {
            position: absolute;
            inset: 0;
            background: radial-gradient(circle at center, #020617 0%, #000000 60%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 30;
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 3px solid rgba(0, 212, 255, 0.3);
            border-top: 3px solid #00d4ff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 18px;
        }

        .loading-text {
            font-family: 'Orbitron', monospace;
            color: #00d4ff;
            font-size: 1rem;
            letter-spacing: 0.15em;
            text-transform: uppercase;
        }

        #damageIndicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(1);
            font-family: 'Orbitron', monospace;
            font-size: 2rem;
            color: #ff073a;
            text-shadow: 0 0 26px rgba(255, 7, 58, 1);
            opacity: 0;
            pointer-events: none;
            z-index: 15;
            letter-spacing: 0.2em;
        }

        .hidden {
            display: none !important;
        }

        @keyframes rotate {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @media (max-width: 768px) {
            #speedometer {
                width: 150px;
                height: 150px;
                bottom: 20px;
                right: 20px;
            }

            #minimap {
                width: 170px;
                height: 170px;
                top: 20px;
                right: 20px;
            }

            #scoreDisplay {
                top: 20px;
                left: 20px;
                padding: 14px 16px;
            }

            #controlPanel {
                bottom: 20px;
                left: 20px;
                padding: 12px 14px;
            }

            #gameMenu {
                width: 90%;
                padding: 24px 20px;
            }

            #gameMenu h1 {
                font-size: 2.3rem;
            }
        }
    </style>
</head>
<body>
<div id="gameContainer">
    <canvas id="gameCanvas"></canvas>

    <div id="uiOverlay">
        <!-- Speedometer -->
        <div id="speedometer" class="ui-panel">
            <div class="speed-value" id="speedValue">0</div>
            <div class="speed-unit">KM/H</div>
        </div>

        <!-- Minimap -->
        <div id="minimap" class="ui-panel">
            <canvas id="minimapCanvas" width="220" height="220"></canvas>
        </div>

        <!-- Score Display -->
        <div id="scoreDisplay" class="ui-panel">
            <div class="score-item">
                <span class="score-label">SCORE</span>
                <span class="score-value" id="currentScore">0</span>
            </div>
            <div class="score-item">
                <span class="score-label">COMBO</span>
                <span class="score-value" id="comboMultiplier">x1</span>
            </div>
            <div class="score-item">
                <span class="score-label">CASH</span>
                <span class="score-value" id="cashEarned">$0</span>
            </div>
        </div>

        <!-- Control Panel -->
        <div id="controlPanel" class="ui-panel">
            <button class="control-btn" id="pauseBtn">PAUSE</button>
            <button class="control-btn" id="resetBtn">RESET</button>
            <button class="control-btn" id="boostBtn">BOOST</button>
        </div>

        <!-- Damage Indicator -->
        <div id="damageIndicator">CRITICAL DAMAGE</div>
    </div>

    <!-- Game Menu -->
    <div id="gameMenu" class="hidden">
        <h1>URBAN VELOCITY</h1>
        <p class="menu-subtitle">STREET RACING REVOLUTION</p>
        <div class="menu-buttons">
            <button class="menu-btn" id="startRaceBtn">START RACE</button>
            <button class="menu-btn" id="garageBtn">GARAGE</button>
            <button class="menu-btn" id="leaderboardBtn">LEADERBOARD</button>
            <button class="menu-btn" id="settingsBtn">SETTINGS</button>
        </div>
        <p style="color:#9ca3af;font-size:0.8rem;letter-spacing:0.15em;text-transform:uppercase;">
            WASD / Arrows to steer • Space for handbrake • Boost button / X (Pad)
        </p>
    </div>

    <!-- Loading Screen -->
    <div id="loadingScreen">
        <div class="loading-spinner"></div>
        <div class="loading-text">INITIALIZING RACING ENGINE...</div>
    </div>
</div>

<script>
    // Game state
    class GameState {
        constructor() {
            this.isRunning = false;
            this.isPaused = false;
            this.score = 0;
            this.combo = 1;
            this.cash = 0;
            this.speed = 0;
            this.damage = 0;
            this.maxSpeed = 260;
            this.acceleration = 0.8;
            this.handling = 0.9;
            this.selectedCar = 'neon-coupe';
        }

        updateScore(points) {
            this.score += Math.floor(points * this.combo);
            this.updateUI();
        }

        updateCombo(multiplier) {
            this.combo = Math.min(multiplier, 10);
            this.updateUI();
        }

        updateCash(amount) {
            this.cash += amount;
            this.updateUI();
        }

        updateSpeed(newSpeed) {
            this.speed = Math.min(newSpeed, this.maxSpeed);
            this.updateUI();
        }

        updateUI() {
            document.getElementById('currentScore').textContent = this.score.toLocaleString();
            document.getElementById('comboMultiplier').textContent = `x${this.combo}`;
            document.getElementById('cashEarned').textContent = `$${this.cash.toLocaleString()}`;
            document.getElementById('speedValue').textContent = Math.floor(this.speed);
        }

        reset() {
            this.score = 0;
            this.combo = 1;
            this.speed = 0;
            this.damage = 0;
            this.updateUI();
        }
    }

    // Input
    class InputManager {
        constructor() {
            this.keys = {};
            this.mouse = { x: 0, y: 0, pressed: false };
            this.gamepad = null;
            this.setupEventListeners();
        }

        setupEventListeners() {
            document.addEventListener('keydown', e => {
                this.keys[e.code] = true;
            });

            document.addEventListener('keyup', e => {
                this.keys[e.code] = false;
            });

            document.addEventListener('mousemove', e => {
                this.mouse.x = e.clientX;
                this.mouse.y = e.clientY;
            });

            document.addEventListener('mousedown', () => { this.mouse.pressed = true; });
            document.addEventListener('mouseup', () => { this.mouse.pressed = false; });

            window.addEventListener('gamepadconnected', e => {
                this.gamepad = e.gamepad;
                console.log('Gamepad connected:', e.gamepad.id);
            });

            window.addEventListener('gamepaddisconnected', () => {
                this.gamepad = null;
            });
        }

        getInputState() {
            const state = {
                accelerate: false,
                brake: false,
                steerLeft: false,
                steerRight: false,
                boost: false,
                handbrake: false,
                steerValue: 0
            };

            // Keyboard
            state.accelerate = this.keys['KeyW'] || this.keys['ArrowUp'];
            state.brake     = this.keys['KeyS'] || this.keys['ArrowDown'];
            state.steerLeft = this.keys['KeyA'] || this.keys['ArrowLeft'];
            state.steerRight= this.keys['KeyD'] || this.keys['ArrowRight'];
            state.handbrake = this.keys['Space'];

            // Combine steering for keyboard
            if (state.steerLeft) state.steerValue -= 1;
            if (state.steerRight) state.steerValue += 1;

            // Mouse steering (optional)
            if (this.mouse.pressed) {
                const centerX = window.innerWidth / 2;
                state.steerValue += (this.mouse.x - centerX) / centerX;
            }

            // Gamepad
            if (this.gamepad) {
                const gp = navigator.getGamepads()[this.gamepad.index];
                if (gp) {
                    state.accelerate = state.accelerate || gp.buttons[7].value > 0.3; // R2
                    state.brake      = state.brake     || gp.buttons[6].value > 0.3; // L2
                    state.steerValue = gp.axes[0]; // Left stick X
                    state.boost      = state.boost    || gp.buttons[0].pressed; // X
                    state.handbrake  = state.handbrake|| gp.buttons[1].pressed; // O
                }
            }

            return state;
        }
    }

    // Car
    class Car {
        constructor(scene, position = { x: 0, y: 0.7, z: 0 }) {
            this.scene = scene;
            this.position = position;
            this.velocity = { x: 0, y: 0, z: 0 };
            this.rotation = 0;
            this.speed = 0;
            this.damage = 0;
            this.mesh = null;
            this.wheels = [];
            this.createMesh();
        }

        createMesh() {
            const carGroup = new THREE.Group();

            // Main body
            const bodyGeometry = new THREE.BoxGeometry(4.6, 0.8, 2.2);
            const bodyMaterial = new THREE.MeshPhysicalMaterial({
                color: 0x00e0ff,
                emissive: 0x00141f,
                metalness: 0.9,
                roughness: 0.1,
                clearcoat: 1.0,
                clearcoatRoughness: 0.15
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.castShadow = true;
            body.receiveShadow = true;
            body.position.y = 0.6;
            carGroup.add(body);

            // Cabin
            const cabinGeometry = new THREE.BoxGeometry(2.2, 0.7, 1.6);
            const cabinMaterial = new THREE.MeshPhysicalMaterial({
                color: 0x070b11,
                emissive: 0x030712,
                transparent: true,
                opacity: 0.9,
                metalness: 0.2,
                roughness: 0.05
            });
            const cabin = new THREE.Mesh(cabinGeometry, cabinMaterial);
            cabin.position.set(0, 1.05, -0.05);
            cabin.castShadow = true;
            carGroup.add(cabin);

            // Spoiler
            const spoilerGeom = new THREE.BoxGeometry(1.8, 0.15, 0.8);
            const spoilerMat = new THREE.MeshPhysicalMaterial({
                color: 0x00e0ff,
                emissive: 0x00101a,
                metalness: 0.9,
                roughness: 0.15
            });
            const spoiler = new THREE.Mesh(spoilerGeom, spoilerMat);
            spoiler.position.set(0, 1.0, -1.1);
            carGroup.add(spoiler);

            // Headlights
            const lightGeom = new THREE.BoxGeometry(0.35, 0.2, 0.1);
            const headMat = new THREE.MeshBasicMaterial({
                color: 0x99f6ff,
                emissive: 0x99f6ff
            });

            const headLeft = new THREE.Mesh(lightGeom, headMat);
            headLeft.position.set(1.4, 0.55, 1.15);

            const headRight = headLeft.clone();
            headRight.position.x = -1.4;

            carGroup.add(headLeft, headRight);

            // Taillights
            const tailMat = new THREE.MeshBasicMaterial({
                color: 0xff0044,
                emissive: 0xff0044
            });
            const tailLeft = new THREE.Mesh(lightGeom, tailMat);
            tailLeft.position.set(1.4, 0.55, -1.25);

            const tailRight = tailLeft.clone();
            tailRight.position.x = -1.4;

            carGroup.add(tailLeft, tailRight);

            // Underglow
            const underGeom = new THREE.PlaneGeometry(4.8, 2.4);
            const underMat = new THREE.MeshBasicMaterial({
                color: 0x00e0ff,
                transparent: true,
                opacity: 0.35,
                side: THREE.DoubleSide
            });
            const underglow = new THREE.Mesh(underGeom, underMat);
            underglow.rotation.x = -Math.PI / 2;
            underglow.position.y = 0.1;
            carGroup.add(underglow);

            // Wheels
            const wheelGeometry = new THREE.CylinderGeometry(0.7, 0.7, 0.5, 18);
            const wheelMaterial = new THREE.MeshStandardMaterial({
                color: 0x111827,
                metalness: 0.5,
                roughness: 0.3
            });

            const wheelPositions = [
                { x: 1.6, y: 0.25, z: 1.0 },
                { x: -1.6, y: 0.25, z: 1.0 },
                { x: 1.6, y: 0.25, z: -1.0 },
                { x: -1.6, y: 0.25, z: -1.0 }
            ];

            this.wheels = wheelPositions.map(pos => {
                const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                wheel.rotation.z = Math.PI / 2;
                wheel.position.set(pos.x, pos.y, pos.z);
                wheel.castShadow = true;
                wheel.receiveShadow = true;
                carGroup.add(wheel);
                return wheel;
            });

            carGroup.position.set(this.position.x, this.position.y, this.position.z);

            this.mesh = carGroup;
            this.scene.add(this.mesh);
        }

        update(inputState, deltaTime) {
            if (!this.mesh) return;

            // Acceleration / brake
            if (inputState.accelerate) {
                this.speed = Math.min(this.speed + gameState.acceleration * 60 * deltaTime, gameState.maxSpeed);
            } else if (inputState.brake) {
                this.speed = Math.max(this.speed - 80 * deltaTime, -gameState.maxSpeed * 0.25);
            } else {
                // Natural drag
                this.speed *= 0.985;
            }

            // Handbrake = heavy lateral drift + speed cut
            if (inputState.handbrake) {
                this.speed *= 0.97;
            }

            // Steering
            const steerIntensity = inputState.steerValue;
            if (Math.abs(steerIntensity) > 0.05) {
                const steerAmount = steerIntensity * 2.0 * (this.speed / gameState.maxSpeed);
                this.rotation += steerAmount * deltaTime;
            }

            // Position update
            const forwardX = Math.sin(this.rotation);
            const forwardZ = Math.cos(this.rotation);
            const moveFactor = this.speed * deltaTime * 0.25;

            this.mesh.position.x += forwardX * moveFactor;
            this.mesh.position.z += forwardZ * moveFactor;
            this.mesh.rotation.y = this.rotation;

            // Wheel spin
            const wheelSpin = this.speed * deltaTime * 0.15;
            this.wheels.forEach(w => w.rotation.x += wheelSpin);

            // Update game state
            gameState.updateSpeed(Math.abs(this.speed));

            // Bounds + damage
            this.keepInBounds();
        }

        keepInBounds() {
            const boundsX = 12;   // keep within road width
            const boundsZ = 480;  // track length

            if (Math.abs(this.mesh.position.x) > boundsX) {
                this.mesh.position.x = Math.sign(this.mesh.position.x) * boundsX;
                this.speed *= -0.35;
                this.takeDamage(6);
            }

            if (this.mesh.position.z > boundsZ) {
                this.mesh.position.z = -boundsZ;
            } else if (this.mesh.position.z < -boundsZ) {
                this.mesh.position.z = boundsZ;
            }
        }

        takeDamage(amount) {
            this.damage += amount;
            gameState.damage = this.damage;

            if (this.damage > 40) {
                this.showDamageIndicator();
            }

            if (this.mesh && this.damage > 25) {
                this.mesh.children.forEach(child => {
                    if (child.material && child.material.color) {
                        child.material.color.offsetHSL(0.01, -0.02, -0.02);
                    }
                });
            }
        }

        showDamageIndicator() {
            const indicator = document.getElementById('damageIndicator');
            indicator.style.transition = 'none';
            indicator.style.opacity = '1';
            indicator.style.transform = 'translate(-50%, -50%) scale(1.1)';

            setTimeout(() => {
                indicator.style.transition = 'opacity 0.4s ease, transform 0.4s ease';
                indicator.style.opacity = '0';
                indicator.style.transform = 'translate(-50%, -50%) scale(1)';
            }, 250);
        }

        destroy() {
            if (this.mesh) {
                this.scene.remove(this.mesh);
            }
        }
    }

    // Game engine
    class RacingGame {
        constructor() {
            this.scene = null;
            this.camera = null;
            this.renderer = null;
            this.car = null;
            this.inputManager = new InputManager();
            this.clock = new THREE.Clock();
            this.gameStarted = false;
            this.isPaused = false;

            this.init();
        }

        init() {
            this.setupScene();
            this.setupLighting();
            this.setupEnvironment();
            this.setupCar();
            this.setupEventListeners();
            this.hideLoadingScreen();
            this.showMainMenu();
        }

        setupScene() {
            this.scene = new THREE.Scene();
            this.scene.fog = new THREE.FogExp2(0x020617, 0.0035);

            this.camera = new THREE.PerspectiveCamera(
                70,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            this.camera.position.set(0, 7, 16);

            this.renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('gameCanvas'),
                antialias: true
            });
            this.renderer.setSize(window.innerWidth, window.innerHeight);
            this.renderer.setPixelRatio(window.devicePixelRatio || 1);
            this.renderer.setClearColor(0x020617);
            this.renderer.shadowMap.enabled = true;
            this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        }

        setupLighting() {
            const ambientLight = new THREE.AmbientLight(0x1f2933, 0.7);
            this.scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(40, 80, 20);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            this.scene.add(dirLight);

            const neonLeft = new THREE.PointLight(0x00e0ff, 1.5, 120);
            neonLeft.position.set(-9, 5, 0);
            this.scene.add(neonLeft);

            const neonRight = new THREE.PointLight(0xff1f71, 1.5, 120);
            neonRight.position.set(9, 5, 0);
            this.scene.add(neonRight);
        }

        setupEnvironment() {
            // Base ground (dark)
            const groundGeom = new THREE.PlaneGeometry(80, 1200);
            const groundMat = new THREE.MeshPhongMaterial({
                color: 0x05070b,
                shininess: 5
            });
            const ground = new THREE.Mesh(groundGeom, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            this.scene.add(ground);

            // Asphalt road
            const roadGeom = new THREE.PlaneGeometry(24, 1200);
            const roadMat = new THREE.MeshStandardMaterial({
                color: 0x111827,
                roughness: 0.8,
                metalness: 0.1
            });
            const road = new THREE.Mesh(roadGeom, roadMat);
            road.rotation.x = -Math.PI / 2;
            road.position.y = 0.02;
            road.receiveShadow = true;
            this.scene.add(road);

            // Lane markings (center dashed line)
            const dashGeom = new THREE.BoxGeometry(0.5, 0.02, 6);
            const dashMat = new THREE.MeshBasicMaterial({ color: 0xf9fafb });
            for (let i = -550; i < 550; i += 16) {
                const dash = new THREE.Mesh(dashGeom, dashMat);
                dash.position.set(0, 0.04, i);
                this.scene.add(dash);
            }

            // Side glow strips
            const sideGlowGeom = new THREE.PlaneGeometry(1, 1200);
            const leftGlowMat = new THREE.MeshBasicMaterial({
                color: 0x00e0ff,
                transparent: true,
                opacity: 0.45,
                side: THREE.DoubleSide
            });
            const rightGlowMat = new THREE.MeshBasicMaterial({
                color: 0xff1f71,
                transparent: true,
                opacity: 0.45,
                side: THREE.DoubleSide
            });

            const leftGlow = new THREE.Mesh(sideGlowGeom, leftGlowMat);
            leftGlow.rotation.x = -Math.PI / 2;
            leftGlow.position.set(-11.5, 0.03, 0);

            const rightGlow = new THREE.Mesh(sideGlowGeom, rightGlowMat);
            rightGlow.rotation.x = -Math.PI / 2;
            rightGlow.position.set(11.5, 0.03, 0);

            this.scene.add(leftGlow, rightGlow);

            // Simple city silhouettes on the horizon
            const buildingMaterial = new THREE.MeshPhongMaterial({
                color: 0x020617,
                emissive: 0x020617
            });

            for (let i = 0; i < 26; i++) {
                const width = Math.random() * 4 + 3;
                const height = Math.random() * 20 + 10;
                const depth = Math.random() * 4 + 3;

                const geom = new THREE.BoxGeometry(width, height, depth);
                const meshLeft = new THREE.Mesh(geom, buildingMaterial);
                meshLeft.position.set(-24 - Math.random() * 30, height / 2, (Math.random() - 0.5) * 1000);
                meshLeft.receiveShadow = true;
                this.scene.add(meshLeft);

                const meshRight = meshLeft.clone();
                meshRight.position.x = 24 + Math.random() * 30;
                this.scene.add(meshRight);
            }
        }

        setupCar() {
            this.car = new Car(this.scene);
        }

        setupEventListeners() {
            window.addEventListener('resize', () => {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            });

            document.getElementById('startRaceBtn').addEventListener('click', () => {
                this.startGame();
            });

            document.getElementById('garageBtn').addEventListener('click', () => {
                alert('Garage view not implemented yet (placeholder).');
            });

            document.getElementById('leaderboardBtn').addEventListener('click', () => {
                alert('Leaderboard not implemented yet (placeholder).');
            });

            document.getElementById('settingsBtn').addEventListener('click', () => {
                alert('Settings not implemented yet (placeholder).');
            });

            document.getElementById('pauseBtn').addEventListener('click', () => {
                this.togglePause();
            });

            document.getElementById('resetBtn').addEventListener('click', () => {
                this.resetGame();
            });

            document.getElementById('boostBtn').addEventListener('click', () => {
                this.activateBoost();
            });
        }

        startGame() {
            this.gameStarted = true;
            gameState.isRunning = true;
            document.getElementById('gameMenu').classList.add('hidden');
            this.clock.getDelta(); // reset
            this.animate();
        }

        togglePause() {
            this.isPaused = !this.isPaused;
            gameState.isPaused = this.isPaused;
            if (!this.isPaused) {
                this.clock.getDelta();
                this.animate();
            }
        }

        resetGame() {
            gameState.reset();
            if (this.car) {
                this.car.destroy();
            }
            this.setupCar();
        }

        activateBoost() {
            if (this.car && this.car.speed > 40) {
                this.car.speed = Math.min(this.car.speed * 1.4, gameState.maxSpeed * 1.15);
                gameState.updateScore(300);
                this.createBoostEffect();
            }
        }

        createBoostEffect() {
            if (!this.car || !this.car.mesh) return;
            const origin = this.car.mesh.position.clone();

            const geom = new THREE.ConeGeometry(1.2, 4, 16, 1, true);
            const mat = new THREE.MeshBasicMaterial({
                color: 0x00e0ff,
                transparent: true,
                opacity: 0.55,
                side: THREE.DoubleSide
            });

            const cone = new THREE.Mesh(geom, mat);
            cone.rotation.x = Math.PI;
            cone.position.set(origin.x, 0.3, origin.z + Math.cos(this.car.rotation) * -2);
            this.scene.add(cone);

            setTimeout(() => {
                mat.opacity = 0;
                this.scene.remove(cone);
            }, 250);
        }

        updateCamera() {
            if (!this.car || !this.car.mesh) return;

            const offsetBack = 13;
            const offsetUp = 6;

            const targetPos = new THREE.Vector3(
                this.car.mesh.position.x - Math.sin(this.car.rotation) * offsetBack,
                this.car.mesh.position.y + offsetUp,
                this.car.mesh.position.z - Math.cos(this.car.rotation) * offsetBack
            );

            this.camera.position.lerp(targetPos, 0.12);
            const lookAtPos = this.car.mesh.position.clone();
            lookAtPos.y += 1.2;
            this.camera.lookAt(lookAtPos);
        }

        animate() {
            if (this.isPaused || !this.gameStarted) return;

            requestAnimationFrame(() => this.animate());

            const deltaTime = this.clock.getDelta();
            const inputState = this.inputManager.getInputState();

            if (this.car) {
                this.car.update(inputState, deltaTime);
            }

            this.updateCamera();
            this.updateMinimap();

            if (this.car && Math.abs(this.car.speed) > 5) {
                gameState.updateScore(Math.abs(this.car.speed) * 0.08);
            }

            this.renderer.render(this.scene, this.camera);
        }

        updateMinimap() {
            const canvas = document.getElementById('minimapCanvas');
            const ctx = canvas.getContext('2d');

            ctx.fillStyle = '#020617';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw road rectangle
            ctx.fillStyle = '#111827';
            ctx.fillRect(canvas.width / 2 - 28, 10, 56, canvas.height - 20);

            // Center line
            ctx.strokeStyle = '#4b5563';
            ctx.setLineDash([4, 4]);
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(canvas.width / 2, 12);
            ctx.lineTo(canvas.width / 2, canvas.height - 12);
            ctx.stroke();
            ctx.setLineDash([]);

            if (this.car && this.car.mesh) {
                const zRange = 480;
                const xRange = 12;

                const x = canvas.width / 2 + (this.car.mesh.position.x / xRange) * 26;
                const zNorm = (this.car.mesh.position.z + zRange) / (2 * zRange);
                const y = canvas.height - 12 - zNorm * (canvas.height - 24);

                // Car dot
                ctx.fillStyle = '#00e0ff';
                ctx.beginPath();
                ctx.arc(x, y, 5, 0, Math.PI * 2);
                ctx.fill();

                // Direction line
                ctx.strokeStyle = '#00e0ff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(
                    x + Math.sin(this.car.rotation) * 14,
                    y - Math.cos(this.car.rotation) * 14
                );
                ctx.stroke();
            }
        }

        hideLoadingScreen() {
            setTimeout(() => {
                const loading = document.getElementById('loadingScreen');
                loading.style.transition = 'opacity 0.5s ease';
                loading.style.opacity = '0';
                setTimeout(() => {
                    loading.style.display = 'none';
                }, 550);
            }, 2000);
        }

        showMainMenu() {
            setTimeout(() => {
                document.getElementById('gameMenu').classList.remove('hidden');
            }, 2300);
        }
    }

    let gameState, racingGame;

    window.addEventListener('DOMContentLoaded', () => {
        gameState = new GameState();
        racingGame = new RacingGame();
    });
</script>
</body>
</html>
